---
title: 网络编程高频总结一
date: 2025-01-10 07:05 +0800
last_modified_at: 2025-01-10 07:05 +0800
author: FeetingTimes
categories: ["网络编程", "网络编程面经"]
tags: ["网络编程", "面经"]
pin: true
math: true
mermaid: true
img_path: /assets/img/
---

## 为什么握手是三次而挥手需要四次

在计算机网络中，TCP（传输控制协议）的三次握手和四次挥手是建立和终止连接的重要机制。它们的设计逻辑是基于可靠性和安全性，同时兼顾网络通信的效率。以下是详细的解释：

------

### **三次握手的原因**

三次握手的目的是**建立可靠的连接**，确保通信双方都能正常收发数据。具体步骤如下：

1. **第一次握手 (SYN)**
    客户端发送一个 SYN（同步序列号）报文，表明希望建立连接，同时告诉服务器自己的初始序列号。
2. **第二次握手 (SYN-ACK)**
    服务器收到客户端的 SYN 报文后，回复一个 SYN-ACK 报文，表明自己同意建立连接，同时也发送自己的初始序列号。
3. **第三次握手 (ACK)**
    客户端收到服务器的 SYN-ACK 后，再发送一个 ACK 报文，表示确认服务器的响应，连接正式建立。

**为什么是三次？**
 三次握手可以有效避免历史旧连接（延迟的报文）对当前通信的干扰，同时确认双方的接收和发送能力：

- 第一次：确认客户端的发送能力。
- 第二次：确认服务器的接收和发送能力。
- 第三次：确认客户端的接收能力。

------

### **四次挥手的原因**

四次挥手的目的是**优雅地关闭连接**，确保通信双方都能正确终止数据传输。具体步骤如下：

1. **第一次挥手 (FIN)**
    客户端发送一个 FIN 报文，表示自己没有数据要发送了，请求关闭连接。
2. **第二次挥手 (ACK)**
    服务器收到 FIN 后，回复一个 ACK 报文，表示收到关闭请求，但可能还有数据要处理。
3. **第三次挥手 (FIN)**
    服务器处理完数据后，发送一个 FIN 报文，表示自己也没有数据要发送了，请求关闭连接。
4. **第四次挥手 (ACK)**
    客户端收到服务器的 FIN 后，回复一个 ACK 报文，确认关闭连接。

**为什么是四次？**
 TCP 是全双工协议，双方的发送和接收是独立的，连接关闭需要分别进行：

- 前两次（FIN 和 ACK）用于关闭一方的发送通道。
- 后两次（FIN 和 ACK）用于关闭另一方的发送通道。

这确保双方都有机会完成未发送的数据，避免数据丢失。

------

### **总结**

- **三次握手：** 双方需要协商建立连接，确认彼此的接收和发送能力。
- **四次挥手：** 双方需要分别关闭发送通道，确保未发送的数据完整传输。

这两种机制的设计初衷都是为了保证可靠通信的同时，避免资源浪费或数据丢失。

## tcp和udp的原理、区别、应用场景

TCP 和 UDP 是两种不同的传输层协议，各有特点和适用场景。

------

### **1. TCP 的原理**

TCP（Transmission Control Protocol）是一种**面向连接**的、可靠的传输协议，适用于需要高可靠性的数据传输。

#### **TCP报文结构** ####

![TCP报文结构](TCP报文结构.png)

------

#### **TCP首部结构** ####

![TCP首部结构](TCP首部结构.png)

TCP：状态控制码（Code，Control Flag），占 6 比特，含义如下：

- URG：紧急比特（urgent），当 `URG＝1` 时，表明紧急指针字段有效，代表该封包为紧急封包。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)， 且上图中的 Urgent Pointer 字段也会被启用。
- ACK：确认比特（Acknowledge）。只有当 `ACK＝1` 时确认号字段才有效，代表这个封包为确认封包。当 `ACK＝0` 时，确认号无效。
- PSH：（Push function）若为 1 时，代表要求对方立即传送缓冲区内的其他对应封包，而无需等缓冲满了才送。
- RST：复位比特(Reset)，当 `RST＝1` 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。
- SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
- FIN：终止比特(Final)，用来释放一个连接。当 `FIN＝1` 时，表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。

------

#### **工作原理**

- **三次握手：** 在通信前建立可靠的连接。
- **数据传输：** 数据分片后传输，接收方按序重组，确保完整性。
- **超时重传：** 如果未收到确认（ACK），发送方会重发数据包。
- **流量控制：** 使用滑动窗口机制，控制发送方的发送速率，防止接收方过载。
- **拥塞控制：** 动态调整传输速率，避免网络拥堵。
- **四次挥手：** 连接结束时，双方独立关闭发送和接收。

------

### **2. UDP 的原理**

UDP（User Datagram Protocol）是一种**无连接**的、轻量级的传输协议，注重效率。

#### **TCP报文结构** ####

![UDP报文结构](UDP报文结构.png)

------

#### **TCP首部结构** ####

![UDP首部结构](UDP首部结构.png)

------

#### **工作原理**

- **无连接：** 发送方直接将数据报（Datagram）发送给接收方，无需建立连接。
- **尽力而为：** 不保证数据一定能到达，数据可能丢失、重复或乱序。
- **数据传输：** 数据直接传递到应用层，开销小，延迟低。

------

### **3. TCP 和 UDP 的区别**

| 特性         | TCP                                        | UDP                                  |
| ------------ | ------------------------------------------ | ------------------------------------ |
| **是否连接** | 面向连接（需要三次握手建立连接）           | 无连接（无需建立连接）               |
| **可靠性**   | 可靠传输（有确认、重传、排序、流量控制）   | 不可靠传输（无确认、不重传、不排序） |
| **数据顺序** | 保证数据按顺序到达                         | 不保证数据按顺序到达                 |
| **传输效率** | 传输效率较低（建立连接和校验机制增加开销） | 传输效率高（无连接、低开销）         |
| **传输单位** | 数据流（Stream）                           | 数据报（Datagram）                   |
| **适用场景** | 适合可靠性要求高的场景                     | 适合实时性、效率要求高的场景         |

------

### **4. TCP 和 UDP 的应用场景**

#### **TCP 的应用场景**

TCP 适用于对数据传输可靠性要求高的场景，如：

1. **Web 服务：** HTTP/HTTPS 使用 TCP，确保网页内容完整传输。
2. **文件传输：** FTP、SFTP 使用 TCP，保障文件不丢失、不损坏。
3. **电子邮件：** SMTP、POP3、IMAP 协议使用 TCP，确保邮件可靠投递。
4. **远程登录：** SSH、Telnet 使用 TCP，保障命令顺序和响应完整性。
5. **数据库通信：** SQL 数据库的查询和更新，要求高可靠性。

#### **UDP 的应用场景**

UDP 适用于对数据传输实时性要求高的场景，如：

1. **流媒体传输：** 视频直播、IPTV 使用 UDP，实时播放优先于丢包修复。
2. **在线游戏：** 快速交互优先于数据可靠性，使用 UDP 传输游戏状态。
3. **语音和视频通话：** VoIP、视频会议使用 UDP，确保低延迟。
4. **广播和组播：** DHCP、DNS 查询等使用 UDP 进行广播和多播通信。
5. **IoT 数据传输：** 物联网设备的数据更新，通常选择轻量级的 UDP。

------

### **总结**

- **TCP：** 注重可靠性和数据完整性，适用于文件传输、浏览器访问等。
- **UDP：** 注重效率和实时性，适用于直播、通话和在线游戏等。

选择 TCP 或 UDP 取决于场景需求，是可靠性优先还是效率优先。

## TCP慢启动，拥塞控制实现

TCP 的慢启动和拥塞控制机制是为了在动态网络环境中，平衡带宽利用率与网络拥塞，确保传输的效率和可靠性。以下是两者的详细实现原理与流程。

------

### **1. 慢启动 (Slow Start)**

#### **目的**

慢启动是为了解决初始阶段的带宽探测问题。TCP 不知道网络的容量，因此通过逐步增加发送速率，避免过快导致网络拥塞。

#### **实现细节**

- **拥塞窗口 (Congestion Window, cwnd)：**
   TCP 发送方维护的一个窗口，用于限制未被确认的分组数量。初始时，`cwnd` 通常为 1 个 MSS（最大报文段长度）。
- **阈值 (ssthresh)：**
   拥塞窗口的阈值，当 `cwnd < ssthresh` 时处于慢启动阶段。
- **逐步增长：**
  - 每收到一个 ACK（确认），`cwnd` 增加 1 个 MSS。
  - 因为每轮次（RTT）内发送的报文数量翻倍，呈指数增长。
- **停止条件：**
  - 如果 `cwnd ≥ ssthresh`，进入拥塞避免阶段。
  - 如果发生丢包，进入拥塞控制。

------

### **2. 拥塞控制机制**

#### **目的**

拥塞控制的核心目标是动态调整 `cwnd`，适应网络带宽，避免和缓解拥塞。TCP 的拥塞控制通常分为以下几个阶段：

------

#### **2.1 拥塞避免 (Congestion Avoidance)**

- **进入条件：**
   当 `cwnd` 增长到 `ssthresh` 以上，离开慢启动，进入拥塞避免。
- **增长方式：**
   在拥塞避免阶段，`cwnd` 不再指数增长，而是**线性增长**：
  - 每轮次（RTT）内，`cwnd` 增加$\frac{\text{MSS}}{\text{cwnd}}$，约等于每 RTT 增加 1 MSS。
- **目标：**
   稳步探测网络容量，避免突然增加导致拥塞。

------

#### **2.2 快速重传 (Fast Retransmit)**

- **进入条件：** 如果发送方连续收到 3 个相同的重复 ACK，表明有报文段丢失（非超时）。
- **操作：**
  - 立即重传丢失的报文段，无需等待超时。
  - 将 `ssthresh` 设置为当前 `cwnd` 的一半（触发慢启动门限调整）。

------

#### **2.3 快速恢复 (Fast Recovery)**

- **进入条件：** 与快速重传配合使用，避免重回慢启动阶段。
- **操作：**
  - 将 `cwnd` 减小到 `ssthresh`。
  - 在快速恢复阶段，`cwnd` 继续以线性方式增长。
- **目标：** 通过快速恢复机制，利用网络剩余带宽，减少恢复时间。

------

#### **2.4 超时重传 (Timeout Retransmit)**

- **进入条件：** 如果没有收到 ACK 并发生超时。
- **操作：**
  - `ssthresh` 设置为当前 `cwnd` 的一半。
  - `cwnd` 重置为 1 MSS，重新进入慢启动阶段。

------

### **3. 拥塞控制算法总结**

#### **阶段划分**

| 阶段         | 条件                       | 增长方式               |
| ------------ | -------------------------- | ---------------------- |
| **慢启动**   | `cwnd < ssthresh`          | 指数增长               |
| **拥塞避免** | `cwnd ≥ ssthresh`          | 线性增长               |
| **快速重传** | 收到 3 个重复 ACK          | 减半 `cwnd` 并快速重传 |
| **快速恢复** | 快速重传后继续利用剩余带宽 | 从 `ssthresh` 线性增长 |
| **超时重传** | 超时且未收到 ACK           | 重置 `cwnd` 为 1 MSS   |

------

### **4. 图解过程**

1. **初始阶段：慢启动**
   - 拥塞窗口指数增长。
2. **进入拥塞避免阶段：**
   - 当 `cwnd >= ssthresh` 时，拥塞窗口线性增长。
3. **拥塞发生：**
   - 丢包或超时触发快速恢复或超时重传，`cwnd` 减半或重置。
4. **恢复增长：**
   - 从调整后的 `ssthresh` 开始重新线性增长。

------

### **5. 应用与优化**

- **现代优化：**
  - TCP Tahoe：基础算法，包括慢启动、拥塞避免、超时重传。
  - TCP Reno：引入快速重传与快速恢复。
  - TCP CUBIC、BBR：优化高带宽、低延迟场景。
- **适用场景：**
  - TCP 的拥塞控制特别适用于需要高可靠性且对丢包敏感的应用（如文件传输、网页访问）。

通过慢启动和拥塞控制，TCP 实现了高效、可靠的数据传输，并在各种网络环境下优化了传输性能。

## HTTP是在OSI模型的哪一层

HTTP（Hypertext Transfer Protocol）位于 **OSI模型的应用层**。

在OSI模型中，应用层是第七层，负责为应用程序提供网络服务。HTTP是一种应用层协议，主要用于在客户端（例如Web浏览器）和服务器之间传输超文本数据（如HTML页面、图片等）。它通过底层的传输层协议（如TCP）来实现可靠的数据传输。

### HTTP与OSI模型其他层的关系：

1. **应用层（HTTP）**: 负责定义数据的格式和交换的语义。
2. **表示层**: 负责数据的表示、加密和解码（例如，HTTP响应中的MIME类型）。
3. **会话层**: 管理会话的建立、维护和终止（如长连接）。
4. **传输层（TCP）**: 提供端到端的可靠数据传输。
5. **网络层（IP）**: 负责数据的路由和寻址。
6. **数据链路层**: 提供点到点的数据帧传输。
7. **物理层**: 负责实际的数据位流传输。

因此，HTTP的具体功能主要集中在应用层，而依赖下层协议来完成其工作。

## HTTPS用到的是对称加密还是非对称加密？分别体现在哪里？

**HTTPS**（Hypertext Transfer Protocol Secure）使用了**对称加密**和**非对称加密**的结合，分别体现在以下环节中：

------

### 1. **非对称加密**（用于密钥交换）

- **体现**: 在 HTTPS 握手过程中，用于安全地传输对称加密所需的密钥（会话密钥）。
- 过程:
  1. 客户端（浏览器）连接到服务器后，服务器会发送一个数字证书（包含服务器的公钥）。
  2. 客户端验证证书的有效性（是否被信任的CA签署，是否过期等）。
  3. 客户端使用服务器的公钥加密一个随机生成的会话密钥，并将其发送给服务器。
  4. 服务器使用自己的私钥解密，得到会话密钥。

此时，客户端和服务器已经共享了一个安全的会话密钥，但整个过程通过非对称加密保护了密钥的传输安全。

------

### 2. **对称加密**（用于数据传输）

- **体现**: 在 HTTPS 握手完成后，用共享的会话密钥对客户端与服务器之间的通信数据进行加密。
- 过程:
  1. 双方使用协商好的对称加密算法（如 AES）和会话密钥加密通信数据。
  2. 对称加密的特点是速度快、效率高，适合大规模数据传输。

因此，实际的 HTTP 请求和响应数据传输过程中，使用的是对称加密。

------

### **总结**

- **非对称加密**: 用于密钥交换（建立安全连接的第一步）。
- **对称加密**: 用于实际的数据加密传输。

这种结合利用了非对称加密的安全性和对称加密的高效性，是 HTTPS 的核心设计。
