---
title: 网络编程高频总结二
date: 2025-01-10 07:54 +0800
last_modified_at: 2025-01-10 07:54 +0800
author: fleetime0
categories: ["网络编程", "网络编程面经"]
tags: ["网络编程", "面经"]
pin: true
math: true
mermaid: true
---

## http2和http1的区别

HTTP/2 和 HTTP/1.1 是两代超文本传输协议版本，HTTP/2 是 HTTP/1.1 的改进版本。以下是两者之间的主要区别：

------

### **1. 多路复用 (Multiplexing)**

- HTTP/1.1:
  - 一个 TCP 连接只能处理一个请求/响应对，需多个连接并发（浏览器一般限制为 6 个）。
  - 存在 **队头阻塞**（Head-of-Line Blocking）问题，即一个请求阻塞会影响整个连接。
- HTTP/2:
  - 支持多路复用，在单个 TCP 连接中可以并行处理多个请求和响应。
  - 消除了队头阻塞问题，提升了传输效率。

------

### **2. 二进制分帧 (Binary Framing)**

- **HTTP/1.1**: 使用纯文本协议，容易解析但效率较低。
- **HTTP/2**: 使用二进制协议，将数据分为帧（Frame）传输，易于解析且效率更高。

------

### **3. 头部压缩 (Header Compression)**

- **HTTP/1.1**: 每次请求都需要发送完整的 HTTP 头部，开销较大。
- **HTTP/2**: 使用 HPACK 压缩算法，减少头部的传输冗余。

------

### **4. 服务器推送 (Server Push)**

- **HTTP/1.1**: 不支持服务器主动推送内容，客户端必须先请求资源。
- **HTTP/2**: 支持服务器推送，允许服务器在客户端请求之前主动发送资源，减少加载时间。

------

### **5. 连接管理**

- **HTTP/1.1**: 为减少连接开销，支持 `Keep-Alive` 长连接，但多个请求串行化运行仍不高效。
- **HTTP/2**: 更高效的连接复用，可以充分利用单个连接。

------

### **6. 流量控制和优先级**

- **HTTP/1.1**: 不支持请求优先级，所有请求平等对待。
- **HTTP/2**: 支持对流（Stream）进行优先级设置，资源分配更灵活。

------

### **7. 性能改进**

- **HTTP/1.1**: 为提升性能，开发者常需使用一些技巧，如合并文件、CSS 雪碧图、域名分片等。
- **HTTP/2**: 由于多路复用和头部压缩等特性，这些优化技巧变得不再必要。

------

### **8. 加密**

- **HTTP/1.1**: 加密不是强制的，支持明文传输。
- **HTTP/2**: 严格要求加密（大部分实现要求使用 HTTPS）。

------

### **总结**

HTTP/2 在性能、效率和现代网络需求方面都有显著优势，但需要 HTTPS 支持才能使用。此外，HTTP/2 的复杂性更高，适合现代 web 应用和高流量场景。

## http1.0 / 1.1 /2 / 3

以下是 **HTTP/1.0**、**HTTP/1.1**、**HTTP/2** 和 **HTTP/3** 的详细对比，总结了它们的特点和演进路径：

------

### **1. HTTP/1.0**

- **发布日期**: 1996 年（RFC 1945）
- 特点:
  - **短连接**: 每个请求/响应需要单独建立和关闭一个 TCP 连接。
  - **无状态性**: 不支持持久连接，客户端和服务器之间无法维护会话状态。
  - **基本功能**: 支持 GET、POST、HEAD 三种方法。
  - **效率低下**: 每次建立连接需要耗费 TCP 三次握手时间，影响性能。
  - **无缓存机制**: 缺乏规范的缓存控制方法。

------

### **2. HTTP/1.1**

- **发布日期**: 1997 年（RFC 2068，后更新为 RFC 2616 和 RFC 7230）
- **改进点**:
  1. 持久连接 (Keep-Alive):
     - 默认启用长连接，多个请求可以复用一个 TCP 连接。
  2. 管道化 (Pipelining):
     - 客户端可以同时发送多个请求，但服务器必须按顺序响应（存在队头阻塞问题）。
  3. 缓存机制:
     - 引入 `Cache-Control` 和 `ETag` 等头部，增强缓存控制。
  4. 虚拟主机 (Host Header):
     - 在请求头中增加 `Host` 字段，使同一服务器可以处理多个域名。
  5. 新增方法:
     - 添加 PUT、DELETE、OPTIONS、TRACE 等方法。
  6. 分块传输 (Chunked Transfer Encoding):
     - 支持分块传输大文件，无需知道内容长度。
- **缺点**:
  - 管道化存在队头阻塞问题。
  - 并发限制：浏览器一般限制为每域名 6 个并发连接。

------

### **3. HTTP/2**

- **发布日期**: 2015 年（RFC 7540）
- **主要改进点**:
  1. 多路复用 (Multiplexing):
     - 在单个 TCP 连接中，多个请求/响应可以并行传输，无队头阻塞。
  2. 二进制协议:
     - 替代文本协议，使用二进制帧格式，提高传输效率。
  3. 头部压缩 (HPACK):
     - 使用专门的压缩算法减少 HTTP 头部冗余，降低带宽使用。
  4. 服务器推送 (Server Push):
     - 服务器可主动推送资源到客户端，无需等待请求。
  5. 流优先级:
     - 客户端可为不同的流设置优先级，优化资源分配。
- **缺点**:
  - 依赖 TCP 协议，多路复用虽然缓解了队头阻塞，但 TCP 层的队头阻塞问题仍然存在。
  - 更高的实现复杂性。

------

### **4. HTTP/3**

- **发布日期**: 2022 年（RFC 9114）
- **关键特点**:
  1. 基于 QUIC 协议:
     - 使用 UDP 替代 TCP，实现低延迟和快速握手。
  2. 消除队头阻塞:
     - QUIC 的流控制机制消除了 TCP 队头阻塞问题。
  3. 更快的连接建立:
     - 单次握手即可建立连接并启动加密通信（0-RTT 支持）。
  4. 内置 TLS 加密:
     - 强制加密传输，TLS 集成在 QUIC 协议中，减少握手开销。
  5. 流级别独立性:
     - 每个流独立传输数据，单个流出错不会影响其他流。
- **优势**:
  - 适合移动网络和高延迟环境，网络切换时连接恢复更快。
  - 更高的吞吐量和更低的延迟。
- **缺点**:
  - 实现较复杂，兼容性依赖于客户端和服务器支持。
  - 部分网络可能对 UDP 流量有限制。

------

### **对比总结表**

| 特性           | HTTP/1.0 | HTTP/1.1   | HTTP/2     | HTTP/3                    |
| -------------- | -------- | ---------- | ---------- | ------------------------- |
| **连接管理**   | 短连接   | 长连接     | 多路复用   | 多路复用（基于 QUIC）     |
| **队头阻塞**   | 存在     | 存在       | 缓解       | 消除                      |
| **数据格式**   | 文本     | 文本       | 二进制帧   | 二进制帧                  |
| **头部压缩**   | 不支持   | 不支持     | HPACK 压缩 | QPACK 压缩                |
| **服务器推送** | 不支持   | 不支持     | 支持       | 支持                      |
| **安全性**     | 无加密   | 可选 HTTPS | 强制 HTTPS | 强制加密（QUIC 集成 TLS） |
| **性能**       | 较低     | 一般       | 较高       | 最高                      |
| **协议底层**   | TCP      | TCP        | TCP        | QUIC（基于 UDP）          |

------

### **应用场景**

- **HTTP/1.0**: 已过时，基本不再使用。
- **HTTP/1.1**: 适用于兼容性要求高的传统应用。
- **HTTP/2**: 适合高性能和现代 Web 应用，广泛使用。
- **HTTP/3**: 理想选择，用于低延迟、高吞吐量、移动网络或复杂网络环境。

## get和post区别

GET 和 POST 是 HTTP 协议中两种常用的请求方法，主要用于客户端与服务器之间的数据传输。它们的核心区别体现在数据传输方式、使用场景、安全性等方面：

------

### **1. 数据传输方式**

- **GET**:
  - 数据附加在 URL 的查询字符串中，格式为 `key=value`，以 `?` 分隔多个参数，用 `&` 连接。
  - URL 长度受限制（不同浏览器和服务器限制可能不同）。
  - 适合传递少量、非敏感的数据。
- **POST**:
  - 数据放在请求体中，而不是 URL 中。
  - 没有明确的长度限制，可以发送较大的数据量。

------

### **2. 使用场景**

- **GET**:
  - 用于获取数据，不对服务器产生副作用。
  - 常用于搜索、导航等操作，方便被书签或缓存。
- **POST**:
  - 用于提交数据，可能对服务器状态产生改变（如用户注册、数据上传等）。
  - 常用于需要传递敏感或较大数据的操作。

------

### **3. 参数可见性**

- **GET**:
  - 参数完全暴露在 URL 中，可被查看、缓存或记录。
  - 不适合传递敏感数据，如密码等。
- **POST**:
  - 参数在请求体中，用户不可直接看到。
  - 更适合传递敏感数据。

------

### **4. 缓存行为**

- **GET**:
  - 默认可以被缓存，适合幂等操作。
  - 浏览器会将其结果缓存，可能影响实时性。
- **POST**:
  - 默认不会被缓存，适合非幂等操作。
  - 每次都触发服务器处理。

------

### **5. 安全性**

- **GET**:
  - 参数暴露在 URL 中，可能被记录到日志中。
  - 不安全，不适合传递敏感信息。
- **POST**:
  - 数据在请求体中，稍微更安全。
  - 但如果没有 HTTPS 加密，数据仍可能被截获。

------

### **6. 幂等性**

- **GET**:
  - 幂等，重复请求不会改变服务器的状态。
  - 多次访问同一个 URL，结果应该是相同的。
- **POST**:
  - 非幂等，重复请求可能会导致副作用（如多次扣费、重复提交表单）。

------

### **7. 浏览器支持**

- **GET**:
  - 支持浏览器回退、刷新，无需重新提交请求。
  - URL 可直接复制或分享。
- **POST**:
  - 刷新时会弹出表单重新提交的提示。
  - 不适合直接分享或复制。

------

### **总结对比表**

| 特性             | **GET**                | **POST**                         |
| ---------------- | ---------------------- | -------------------------------- |
| **参数传递方式** | URL 查询字符串         | 请求体                           |
| **数据大小**     | 有长度限制             | 无明确限制                       |
| **安全性**       | 参数暴露，不安全       | 参数隐藏，较安全（需配合 HTTPS） |
| **缓存**         | 默认可缓存             | 默认不可缓存                     |
| **幂等性**       | 幂等                   | 非幂等                           |
| **适用场景**     | 获取数据，如查询、导航 | 提交数据，如表单提交、文件上传   |

------

### **应用示例**

1. **GET 示例**：

   ```http
   GET /search?q=HTTP&sort=desc HTTP/1.1
   Host: example.com
   ```

2. **POST 示例**：

   ```http
   POST /login HTTP/1.1
   Host: example.com
   Content-Type: application/x-www-form-urlencoded
   
   username=johndoe&password=123456
   ```

## WebSocket

### **WebSocket**

WebSocket 是一种全双工的通信协议，用于在客户端和服务器之间建立持久化连接，适合实时通信场景。它与 HTTP 不同，具有显著的特点和应用优势。

------

### **1. 什么是 WebSocket？**

- **定义**: WebSocket 是 HTML5 标准的一部分，提供了在单个 TCP 连接上进行双向通信的能力。
- **工作原理**: 使用 HTTP 协议完成初始握手后，切换到专用的 WebSocket 协议进行通信。
- 特点:
  - 全双工通信：客户端和服务器可以同时发送消息。
  - 长连接：一旦连接建立，通信可以持续，无需频繁创建新的连接。

------

### **2. WebSocket 的工作流程**

1. **建立连接**：

   - 客户端通过 HTTP/HTTPS 请求与服务器建立连接。
   - 协议头中包含 `Upgrade: websocket`，表示请求协议升级。

   **请求示例**：

   ```http
   GET /chat HTTP/1.1
   Host: example.com
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
   Sec-WebSocket-Version: 13
   ```

   **服务器响应**：

   ```http
   HTTP/1.1 101 Switching Protocols
   Upgrade: websocket
   Connection: Upgrade
   Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
   ```

2. **通信阶段**：

   - 握手完成后，客户端和服务器之间的通信不再依赖 HTTP 协议。
   - 双方通过 WebSocket 帧交换数据。

3. **关闭连接**：

   - 任一方可以通过发送关闭帧关闭连接。

------

### **3. WebSocket 的特点**

- 全双工通信:
  - 客户端和服务器可以实时地互相发送消息，无需轮询。
- 低延迟:
  - 相比 HTTP 轮询，减少了请求/响应开销和延迟。
- 节省带宽:
  - 一次握手后维持长连接，不需要额外的 HTTP 头部信息。
- 轻量级:
  - 消息传输效率高，适合实时性要求高的场景。

------

### **4. WebSocket 和 HTTP 的对比**

| **特性**     | **HTTP**                     | **WebSocket**                          |
| ------------ | ---------------------------- | -------------------------------------- |
| **通信方式** | 请求-响应模式                | 全双工通信                             |
| **连接类型** | 短连接                       | 长连接                                 |
| **实时性**   | 较低，需要轮询或长轮询实现   | 高实时性                               |
| **开销**     | 每次请求需要完整的 HTTP 头部 | 握手后无额外头部                       |
| **数据方向** | 单向：客户端请求，服务器响应 | 双向：客户端和服务器互发消息           |
| **适用场景** | 静态资源加载、简单交互       | 实时聊天、在线游戏、股票行情等高实时性 |

------

### **5. WebSocket 的应用场景**

1. 实时聊天:
   - 如在线客服、聊天室应用。
2. 在线游戏:
   - 实时性强的多人在线游戏。
3. 实时数据推送:
   - 如股票行情、体育比分更新。
4. 协作工具:
   - 文档协作、白板工具。
5. 物联网:
   - 设备间需要实时通信的 IoT 应用。

------

### **6. WebSocket 的常见框架和库**

- 客户端:

  - JavaScript 中的 `WebSocket`对象（内置支持）。

    ```javascript
    const socket = new WebSocket('wss://example.com/socket');
    
    socket.onopen = () => console.log('WebSocket connected');
    socket.onmessage = (event) => console.log(`Received: ${event.data}`);
    socket.onclose = () => console.log('WebSocket closed');
    socket.onerror = (error) => console.error(`Error: ${error}`);
    ```

- 服务器端:

  - Node.js: `ws`、`socket.io`。
  - Java: Spring WebSocket。
  - Python: `websockets`、`FastAPI`。
  - Golang: `gorilla/websocket`。

------

### **7. WebSocket 的局限性**

1. 兼容性:
   - 不支持的客户端需要降级为 HTTP 长轮询。
2. 复杂性:
   - 需要额外的服务器配置。
3. 连接数量:
   - 每个连接占用服务器资源，高并发场景下需要优化。

------

### **8. 安全性**

- 使用 `wss://`（基于 TLS 的 WebSocket）确保通信加密。
- 验证和授权机制防止未授权访问。
- 防御 WebSocket 特有攻击（如消息注入）。

WebSocket 是现代实时通信的首选协议，通过高效的双向通信为各种实时性要求高的场景提供了良好的支持。

## tcp/ip五层模型

TCP/IP 五层模型是一种计算机网络协议模型，用于描述网络通信的分层结构。它基于 OSI 七层模型进行简化，分为五层：**物理层**、**数据链路层**、**网络层**、**传输层** 和 **应用层**。以下是详细介绍：

------

### **五层模型结构**

| **层次**       | **功能**                                       | **常见协议/设备**                 |
| -------------- | ---------------------------------------------- | --------------------------------- |
| **应用层**     | 提供直接为用户服务的网络功能                   | HTTP, HTTPS, FTP, SMTP, DNS, etc. |
| **传输层**     | 提供端到端的通信，负责数据传输的可靠性         | TCP, UDP                          |
| **网络层**     | 负责路由选择和逻辑地址分配                     | IP, ICMP, ARP, OSPF, BGP          |
| **数据链路层** | 提供帧传输服务，解决相邻节点之间的数据通信问题 | Ethernet, PPP, WLAN, MAC          |
| **物理层**     | 定义物理设备的标准，负责比特流的传输           | 光纤, 双绞线, 无线信号, 网卡      |

------

### **1. 物理层**

- 作用:
  - 负责比特流的物理传输，定义硬件设备的电气、机械、功能和过程特性。
  - 确保数据能通过物理介质（如光纤、电缆、无线信号）传输。
- 设备:
  - 网线、光纤、集线器（Hub）、中继器（Repeater）、物理接口。
- **单位**: 比特（Bit）。

------

### **2. 数据链路层**

- 作用:
  - 负责相邻节点之间的可靠传输。
  - 提供错误检测和流量控制功能。
  - 将比特流组织为帧（Frame）。
- 协议:
  - Ethernet、WLAN、PPP、HDLC。
- 设备:
  - 网卡（NIC）、交换机（Switch）。
- **单位**: 帧（Frame）。

------

### **3. 网络层**

- 作用:
  - 负责路由选择，实现数据包从源地址到目标地址的传输。
  - 解决逻辑地址（IP 地址）的分配和管理。
  - 支持多种网络的互联。
- 协议:
  - IP（IPv4, IPv6）、ICMP、ARP、OSPF、BGP。
- 设备:
  - 路由器（Router）。
- **单位**: 数据包（Packet）。

------

### **4. 传输层**

- 作用:
  - 提供端到端的通信服务，负责可靠性、错误检测和流量控制。
  - 将数据分段（Segment），并为每个段分配端口号。
  - 实现面向连接的传输（TCP）或无连接的传输（UDP）。
- 协议:
  - TCP（Transmission Control Protocol）：可靠传输，适用于文件传输、邮件。
  - UDP（User Datagram Protocol）：不可靠但快速，适用于视频流、语音。
- **单位**: 段（Segment）。

------

### **5. 应用层**

- 作用:
  - 面向用户，提供直接的网络服务。
  - 定义应用程序使用的协议格式，如数据请求和响应规则。
- 协议:
  - HTTP、HTTPS、FTP、SMTP、DNS、Telnet、SNMP。
- 功能:
  - 文件传输、电子邮件、远程登录、网页浏览等。
- **单位**: 数据（Data）。

------

### **五层模型的特点**

1. **简化设计**: 相比 OSI 七层模型，五层模型更贴近实际使用，结构简单。
2. **模块化**: 各层独立实现，功能互不干扰，易于扩展和修改。
3. **高效通信**: 数据从上层到下层逐层封装，反向逐层解封装。

------

### **数据封装与解封装**

- 封装:
  1. **应用层**: 用户数据被打包。
  2. **传输层**: 添加端口号（TCP/UDP Header）。
  3. **网络层**: 添加源和目标 IP 地址（IP Header）。
  4. **数据链路层**: 添加源和目标 MAC 地址，形成帧。
  5. **物理层**: 将帧转化为比特流，通过物理介质传输。
- 解封装:
  - 接收端按照封装的逆过程逐层解封，直至应用层获取数据。

------

### **五层模型和实际网络**

TCP/IP 五层模型广泛用于实际网络中，其简化结构帮助开发者理解网络通信的基本原理，同时指导实际网络协议的设计和实现。例如：

- 网页访问:
  1. 应用层：用户通过 HTTP/HTTPS 发送请求。
  2. 传输层：使用 TCP 确保请求的可靠性。
  3. 网络层：通过 IP 寻址找到目标服务器。
  4. 数据链路层和物理层：实际传输比特流，完成通信。

通过五层模型的分层协作，用户能够顺利地浏览网页或发送数据，体现了协议分层的强大优势。
